<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PIN-YI – Opentelemetry</title><link>https://pin-yi.me/blog/opentelemetry/</link><description>Recent content in Opentelemetry on PIN-YI</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><atom:link href="https://pin-yi.me/blog/opentelemetry/index.xml" rel="self" type="application/rss+xml"/><item><title>如何透過 OpenTelemetry 來收集 Ingress Nginx Controller 的 Metrics 與 Traces 並送到 Datadog 上</title><link>https://pin-yi.me/blog/opentelemetry/opentelemetry-ingress-nginx-controller/</link><pubDate>Wed, 13 Sep 2023 00:00:00 +0000</pubDate><guid>https://pin-yi.me/blog/opentelemetry/opentelemetry-ingress-nginx-controller/</guid><description>
&lt;p>由於最近公司想要導入 Datadog，在測試過程中順便導入 OpenTelemetry 來收集 Metrics 與 Traces 並送到 Datadog 上 ～&lt;/p>
&lt;br>
&lt;p>🔥 這個範例比較特別，因為 Datadog 有提供 Ingress Nginx Controller 的 integrations，可以透過 Datadog Agent 來收集 Metrics，不需要透過 OpenTelemetry Collector 來收集。
( Datadog Agent 請參考：&lt;a href="https://docs.datadoghq.com/containers/kubernetes/" target="_blank" rel="noopener">https://docs.datadoghq.com/containers/kubernetes/&lt;/a> )&lt;/p>
&lt;p>程式部分也同步上傳到 github 上，&lt;a href="https://github.com/880831ian/opentelemetry-ingress-nginx-controller" target="_blank" rel="noopener">可以點我前往&lt;/a>&lt;/p>
&lt;br>
&lt;h2>檔案說明&lt;span class="hx-absolute -hx-mt-20" id="檔案說明">&lt;/span>
&lt;a href="#%e6%aa%94%e6%a1%88%e8%aa%aa%e6%98%8e" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;ul>
&lt;li>
&lt;p>otel-collector.yaml：
OpenTelemetry Collector 的設定檔，主要是設定要收集哪些 metrics、traces，並且要送到哪個 exporter，要注意的是 exporters 的 datadog 需要設定 site、api_key，以及 image 要記得用 otel/opentelemetry-collector-contrib，才會有 datadog 的 exporter。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ingress-nginx-values.yaml：
Ingress Nginx Controller 的設定檔，這邊的 podAnnotations 是為了讓 Ingress Nginx Controller 的 Pod 能夠透過 Datadog agent 收集 metrics 到 Datadog 才加上的。&lt;/p>
&lt;p>config 裡面的設定有很多，主要都是 openTelemetry 的設定，要注意的是 enable-opentelemetry 要設為 true，另外 otlp-collector-host 以及 otlp-collector-port 要送到哪個 collector 等等也要記得設定。
另外如果想要將 LOG 與 Trace 串再一起，記得要把 log-format 設為 json，並且帶入，trace_id 與 span_id ( 這邊有多帶 dd.trace_id 是為了讓 datadog 可以自動串接 LOG &amp;amp; Trace )。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>nginx.yaml：
一個簡單的 Nginx 整套服務 (Deployment、Service、Ingress)，要注意的是 Ingress 需要設定 annotations kubernetes.io/ingress.class: nginx (這個是 Ingress Nginx Controller 的預設 class name)，才會被 Ingress Nginx Controller 接管 (才會有 Load Balancer 的 IP)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;br>
&lt;h2>執行步驟&lt;span class="hx-absolute -hx-mt-20" id="執行步驟">&lt;/span>
&lt;a href="#%e5%9f%b7%e8%a1%8c%e6%ad%a5%e9%a9%9f" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;ol>
&lt;li>
&lt;p>先 clone 這個 repo (廢話 xD)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>先建立 OpenTelemetry Collector，執行以下指令：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>helm upgrade collector &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> opentelemetry-collector &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --repo https://open-telemetry.github.io/opentelemetry-helm-charts &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --install &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --create-namespace &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --namespace opentelemetry &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -f &lt;span style="color:#e6db74">&amp;#34;otel-collector.yaml&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>再建立 Ingress Nginx Controller，執行以下指令：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>helm upgrade ingress-nginx &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> ingress-nginx &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --repo https://kubernetes.github.io/ingress-nginx &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --install &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --create-namespace &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --namespace ingress-nginx &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -f &lt;span style="color:#e6db74">&amp;#34;ingress-nginx-values.yaml&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>接著建立測試用 Nginx 服務，執行以下指令：&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>kubectl apply -f nginx.yaml&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;h2>測試&lt;span class="hx-absolute -hx-mt-20" id="測試">&lt;/span>
&lt;a href="#%e6%b8%ac%e8%a9%a6" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>當你執行完上面的步驟後，你會發現有產生兩個 namespace，一個是 ingress-nginx，另一個是 opentelemetry，並且會有 OpenTelemetry Collector、Ingress Nginx Controller、Nginx 等服務，如下：&lt;/p>
&lt;br>
&lt;figure>&lt;img src="https://pin-yi.me/opentelemetry/opentelemetry-ingress-nginx-controller/1.webp"
alt="啟動服務" width="800">&lt;figcaption>
&lt;p>啟動服務&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;br>
&lt;p>我們試著打 &lt;code>http://nginx.example.com/&lt;/code> (測試網址，需要先在 /etc/hosts 綁定 Ingress Nginx Controller 咬住的 Load Balancer IP)，查看一下 Datadog 的 LOG，看看是否有收到 Nginx 的 LOG (此收集 LOG 的方式是透過在 cluster 上安裝 Datadog 的 agent)，如下：&lt;/p>
&lt;br>
&lt;figure>&lt;img src="https://pin-yi.me/opentelemetry/opentelemetry-ingress-nginx-controller/2.webp"
alt="Datadog LOG" width="1200">&lt;figcaption>
&lt;p>Datadog LOG&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;br>
&lt;p>接著查看 Datadog APM 的 trace，如下：&lt;/p>
&lt;br>
&lt;figure>&lt;img src="https://pin-yi.me/opentelemetry/opentelemetry-ingress-nginx-controller/3.webp"
alt="Datadog APM" width="1200">&lt;figcaption>
&lt;p>Datadog APM&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;br>
&lt;p>由於我們在後面目前沒有串其他服務，所以只有一個 span，之後還有另外兩篇文章是介紹如何串其他服務 (會增加服務以及部分設定)，可以參考看看：&lt;a href="https://github.com/880831ian/opentelemetry-roadrunner" target="_blank" rel="noopener">opentelemetry-roadrunner&lt;/a>、&lt;a href="https://github.com/880831ian/opentelemetry-nodejs" target="_blank" rel="noopener">opentelemetry-nodejs&lt;/a>&lt;/p>
&lt;br>
&lt;p>順便看一下透過 Datadog Agent 收集的 Ingress Nginx Controller 的 Metrics，如下：&lt;/p>
&lt;br>
&lt;figure>&lt;img src="https://pin-yi.me/opentelemetry/opentelemetry-ingress-nginx-controller/4.webp"
alt="Datadog Ingress Nginx Controller 的 Metrics" width="900">&lt;figcaption>
&lt;p>Datadog Ingress Nginx Controller 的 Metrics&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;br>
&lt;p>可以用這些 Metrics 來做 Dashboard，如下：&lt;/p>
&lt;br>
&lt;figure>&lt;img src="https://pin-yi.me/opentelemetry/opentelemetry-ingress-nginx-controller/5.webp"
alt="Datadog Dashboard" width="1000">&lt;figcaption>
&lt;p>Datadog Dashboard&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;br>
&lt;h2>結論&lt;span class="hx-absolute -hx-mt-20" id="結論">&lt;/span>
&lt;a href="#%e7%b5%90%e8%ab%96" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>透過 OpenTelemetry Collector 來收集 Ingress Nginx Controller 的 Metrics 與 Traces 並送到 Datadog 上，這樣就可以透過 Ingress Nginx Controller 的 Metrics 來做監控了，對於 RD 再開發上，有 Traces 也更方便 RD 他們找到程式的瓶頸 (有可能是服務導致的)。&lt;/p>
&lt;br>
&lt;h2>參考資料&lt;span class="hx-absolute -hx-mt-20" id="參考資料">&lt;/span>
&lt;a href="#%e5%8f%83%e8%80%83%e8%b3%87%e6%96%99" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Configure Nginx Ingress Controller to use JSON log format：&lt;a href="https://dev.to/bzon/send-gke-nginx-ingress-controller-logs-to-stackdriver-2ih4" target="_blank" rel="noopener">https://dev.to/bzon/send-gke-nginx-ingress-controller-logs-to-stackdriver-2ih4&lt;/a>&lt;/p>
&lt;p>淺談 OpenTelemetry - Collector Compoents：&lt;a href="https://ithelp.ithome.com.tw/articles/10290703" target="_blank" rel="noopener">https://ithelp.ithome.com.tw/articles/10290703&lt;/a>&lt;/p></description></item><item><title>什麼是 Opentelemetry？可觀測性 (Observability) 又是什麼？</title><link>https://pin-yi.me/blog/opentelemetry/opentelemetry-observability/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0000</pubDate><guid>https://pin-yi.me/blog/opentelemetry/opentelemetry-observability/</guid><description>
&lt;p>在介紹 Opentelemetry 之前，我們要先了解一下目前軟體架構以及基礎設施的演進：&lt;/p>
&lt;br>
&lt;figure>&lt;img src="https://pin-yi.me/opentelemetry/opentelemetry-observability/1.webp"
alt="軟體架構以及基礎設施的演進" width="800">&lt;figcaption>
&lt;p>軟體架構以及基礎設施的演進&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;br>
&lt;p>第一階段在軟體架構設計上較為簡單，不會有什麼特別需要拆分出來的程式，所以都是一整包的程式，再測試以及除錯也比較不會有什麼問題。基礎設施都是使用 VM 或是使用放在 IDC 的機房來當 Server。&lt;/p>
&lt;p>第二階段隨著雲端技術的推出，會開始將服務搬上雲供應商提供的 IaaS 服務，或是使用私有雲給企業放置較機密的內容，其他則放置公有雲上，達成混合雲的模式。&lt;/p>
&lt;p>第三階段隨著雲端技術越來越成熟，有更多的雲端 IaC 以及功能推出，會開始考慮使用分散式的系統架構，將 DB 等服務也改用 Cloud SQL 的方式。在基礎設施上也隨著容器化的技術成熟而進入新的時代。&lt;/p>
&lt;p>第四階段已經使用 docker 來管理好一陣子，但發現虛擬容器技術在管理上十分不方便，因此 K8s 逐漸盛行，將架構從分散式改成微服務的方式進行，在讓開發團隊使用上可以更靈活且容易。&lt;/p>
&lt;br>
&lt;p>雖然使用 K8s 可以讓我們的服務更靈活方便，但也會將服務切的越來越細，這時會讓開發變的十分複雜，我們在架構上從一開始的單體式架構，變成分散式架構，再到最後的微服務，讓開發人員需要處理的事情會越來越多。服務要如何連線？Log 要如何記錄？以及當一個請求會經過多個服務時，相對的延遲也會增加，這時要怎麼去處理等。在監控上，因為服務切分得很細，當線上有一個服務有問題時，要如何快速的找到問題點也是一大挑戰。&lt;/p>
&lt;br>
&lt;p>當我們使用分散式系統或是微服務時發生故障時，會很難快速的恢復服務，因為每個服務都互相依賴，在以往都是透過經驗以及對系統的了解來得以解決。那有什麼其他的方式，能夠讓我們更快掌握每個服務呢？我們先來了解一個名詞：可觀測性(Observability)&lt;/p>
&lt;br>
&lt;h2>可觀測性(Observability)&lt;span class="hx-absolute -hx-mt-20" id="可觀測性observability">&lt;/span>
&lt;a href="#%e5%8f%af%e8%a7%80%e6%b8%ac%e6%80%a7observability" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>可觀測性有三個重要的特性，分別是：&lt;/p>
&lt;p>Metrics 負責監控系統有什麼狀況，當要發生服務故障前可以透過設定閥值搭配告警提早得知。&lt;/p>
&lt;p>Logs 當問題發生時，可以用來查看故障時正在執行哪些服務，以及產生的錯誤資訊。&lt;/p>
&lt;p>Traces （後面詳細介紹）&lt;/p>
&lt;br>
&lt;figure>&lt;img src="https://pin-yi.me/opentelemetry/opentelemetry-observability/2.webp"
alt="可觀測性三大支柱" width="400">&lt;figcaption>
&lt;p>可觀測性三大支柱&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;br>
&lt;p>我們對於 Metrics 跟 Logs 有基本的了解，所以我這邊會注重在 Traces 的部分：&lt;/p>
&lt;p>當有多個微服務的複雜分散式系統，用戶的請求會由系統中的多個微服務進行處理。Metrics 跟 Logs 可以提供我們有關系統如何去處理這些請求的一些資訊，但沒有辦法提供微服務的詳細訊息以及他是如何影響客戶端的請求。這時候就需要透過 Trace 來協助我們追蹤。&lt;/p>
&lt;br>
&lt;p>Trace 可以在連續的時間維度上，透過 Trace 以及 Span 關聯，把空間給排列展示出來，並且有 Trace-Context 規範，能夠直觀的看到請求在分散式系統中經過所有服務的紀錄。&lt;/p>
&lt;p>什麼是 Trace、Span 、Trace-Context 呢？&lt;/p>
&lt;p>我們先說 Span，Span 又可以叫跨度，是系統中最小的單位，可以看下方圖片，SpanA 的資料是來源 SpanB，SpanB 來源是 SpanC 等等，每一個 Span 可以把它想成一個請求後面所有經過服務的工作流程，例如：nginx_module、db、redis 等等。&lt;/p>
&lt;p>請求的整個過程叫做 Trace，那他要怎麼知道 SpanA ~ SpanE 是同一個請求呢？&lt;/p>
&lt;br>
&lt;p>就需要透過 TraceID 以及 SpanID 來記錄：&lt;/p>
&lt;br>
&lt;p>TraceID：是唯一的 ID，用於識別整個分散式追蹤的一條請求路徑。在下方圖片中，當請求進入時，就會被賦予一個 TraceID，所有有經過的 Span 都會記錄此 TraceID，這樣才可以把不同服務依據 TraceID 關聯成同一個請求。&lt;/p>
&lt;p>SpanID：是一條請求路徑中單個操作唯一的 ID。追蹤路徑是由多個 Span 組成，每個 Span 都代表一個操作或特定的時間段。當請求進入時，每個服務就會產生一個 Span 來代表它處理請求的的時間。這些 Span 使用 TraceID 來連接再一起，形成完整的請求追蹤。&lt;/p>
&lt;br>
&lt;figure>&lt;img src="https://pin-yi.me/opentelemetry/opentelemetry-observability/3.webp"
alt="Trace 示意圖" width="650">&lt;figcaption>
&lt;p>Trace 示意圖&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;br>
&lt;p>那要怎麼查看每個 Span 的紀錄內容呢，就需要 Trace-Context：&lt;/p>
&lt;p>會放置一些用於追蹤和識別請求的上下文信息，例如 Trace ID、Span ID 和其他相關的數據。這些上下文信息可以是一些關鍵的數據，可以幫助我們在整個分佈式系統中追蹤請求的路徑，並將相關請求和操作關聯起來。&lt;/p>
&lt;br>
&lt;figure>&lt;img src="https://pin-yi.me/opentelemetry/opentelemetry-observability/4.webp"
alt="ECK Trace 示意圖" width="1200">&lt;figcaption>
&lt;p>ECK Trace 示意圖&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;br>
&lt;p>上面的圖片中，可以看到 call /product/XXXX 後，會經過需多的 Span，隨便點擊一個 Span 可以看到它記錄的 Trace-Context，以及都會包含 TraceID 及 SpanID&lt;/p>
&lt;br>
&lt;figure>&lt;img src="https://pin-yi.me/opentelemetry/opentelemetry-observability/5.webp"
alt="ECK Trace 示意圖" width="900">&lt;figcaption>
&lt;p>ECK Trace 示意圖&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;br>
&lt;p>Trace 優點可以看到跨維度看到中間的資訊，對於找到問題以及瓶頸十分方便，但缺點就是因為需要在 Span 中產生 ID 以及內容，需要在程式裡面加入一定的套件以及調整程式碼。&lt;/p>
&lt;br>
&lt;p>所以我們在可觀測性(Observability)最終的目的是希望可以透過可觀測性工具讓我們知道：&lt;/p>
&lt;ol>
&lt;li>請求通過哪些服務&lt;/li>
&lt;li>每個服務在處理請求時做了些什麼&lt;/li>
&lt;li>如果請求很慢，瓶頸在哪邊&lt;/li>
&lt;li>如果請求失敗，錯誤點在哪&lt;/li>
&lt;li>請求的路徑是什麼&lt;/li>
&lt;li>為什麼花這麼長的時間&lt;/li>
&lt;/ol>
&lt;br>
&lt;h2>Opentelemetry&lt;span class="hx-absolute -hx-mt-20" id="opentelemetry">&lt;/span>
&lt;a href="#opentelemetry" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>那我們這次要介紹的可觀測性(Observability)工具就是 Opentelemetry，縮寫 OTel，它是由 CNCF (Cloud Native Computing Foundation) 組織孵化的開源專案，在 2021 年 5 月由 OpenTracing 與 OpenCensus 兩個框架合併，結合兩項分散式追蹤框架最重要的特性成為下一代收集遙測數據的新標準。&lt;/p>
&lt;br>
&lt;ul>
&lt;li>telemetry&lt;/li>
&lt;/ul>
&lt;p>又叫做遙測，是指能夠跨越不同系統來收集資料 (包含 LOG、Metric、trace) 的能力。&lt;/p>
&lt;br>
&lt;p>我們可以看一下官網的說明：&lt;/p>
&lt;p>Opentelemetry 是雲原生的可觀測性(Observability)框架，提供標準化的 API、SDK 與協議自動檢測、蒐集、導出遙測數據資料 (Metrics、Log、Trace)，並支援 W3C 定義的 Http trace-context 規範，降低開發者在搜集遙測數據上的困難度，以及方便進行後續分析以及性能的優化。&lt;/p>
&lt;br>
&lt;figure>&lt;img src="https://pin-yi.me/opentelemetry/opentelemetry-observability/6.webp"
alt="Opentelemetry" width="500">&lt;figcaption>
&lt;p>Opentelemetry&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;br>
&lt;p>在 OpenTelemetry 核心元件如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>API：開發人員可以透過 OpenTelemetry API 自動生成、蒐集應用程式(Application)的遙測數據資料(Metrics, Log, Trace)，每個程式語言都需實作 OpenTelemetry 規範所定義的 API 方法簽章。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SDK：是 OpenTelemetry API 的實現。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>OTLP：規範定義了遙測數據的編碼與客戶端及服務器之間如何交換的協議 (gRPC、HTTP)。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Collector：OpenTelemetry 中儲存庫，用於接收、處理、導出遙測數據到各種後端平台。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;br>
&lt;h2>參考資料&lt;span class="hx-absolute -hx-mt-20" id="參考資料">&lt;/span>
&lt;a href="#%e5%8f%83%e8%80%83%e8%b3%87%e6%96%99" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Observability：&lt;a href="https://linkedin.github.io/school-of-sre/level101/metrics_and_monitoring/observability/" target="_blank" rel="noopener">https://linkedin.github.io/school-of-sre/level101/metrics_and_monitoring/observability/&lt;/a>&lt;/p>
&lt;p>[OpenTelemetry] 現代化監控使用 OpenTelemetry 實現 : 可觀測性(Observability)：&lt;a href="https://marcus116.blogspot.com/2022/01/modern-monitoring-using-openTelemetry-with-Observability.html" target="_blank" rel="noopener">https://marcus116.blogspot.com/2022/01/modern-monitoring-using-openTelemetry-with-Observability.html&lt;/a>&lt;/p>
&lt;p>[OpenTelemetry] 現代化監控使用 OpenTelemetry 實現 : OpenTelemetry 開放遙測：&lt;a href="https://marcus116.blogspot.com/2022/01/opentelemetry-opentelemetry.html" target="_blank" rel="noopener">https://marcus116.blogspot.com/2022/01/opentelemetry-opentelemetry.html&lt;/a>&lt;/p>
&lt;p>淺談 Observability(下)：&lt;a href="https://ithelp.ithome.com.tw/m/articles/10287598" target="_blank" rel="noopener">https://ithelp.ithome.com.tw/m/articles/10287598&lt;/a>&lt;/p>
&lt;p>Manage services, spans, and traces in Splunk APM：&lt;a href="https://docs.splunk.com/Observability/apm/apm-spans-traces/traces-spans.html" target="_blank" rel="noopener">https://docs.splunk.com/Observability/apm/apm-spans-traces/traces-spans.html&lt;/a>&lt;/p></description></item></channel></rss>