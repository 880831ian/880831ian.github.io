<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PIN-YI – Kubernetes</title><link>https://pin-yi.me/docs/kubernetes/</link><description>Recent content in Kubernetes on PIN-YI</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><atom:link href="https://pin-yi.me/docs/kubernetes/index.xml" rel="self" type="application/rss+xml"/><item><title>正式環境上踩到 StatefulSet 的雷，拿到 P1 的教訓</title><link>https://pin-yi.me/docs/kubernetes/k8s-statefulset-podmanagementpolicy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pin-yi.me/docs/kubernetes/k8s-statefulset-podmanagementpolicy/</guid><description>
&lt;p>此文章要來記錄一下前陣子在公司的正式環境踩到 StatefulSet 的雷，事情是這樣的，我們有些服務，是使用 StatefulSet 來建置，至於為什麼不用 Deployment，這個說來話長 (也不是因為需要特定的 Pod 名稱、或是網路標記等等)，我們這邊先不討論，這個 StatefulSet 服務是 Nginx + PHP-FPM，為了避免流量進入到 processes 已經被用光的 Pod 中，我們在 StatefulSet 的 PHP Container 上有設定 readiness，readiness 的設定長得像以下：&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;div class="code-block relative mt-6 first:mt-0 group/code">&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">readinessProbe&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">exec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">command&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;/bin/bash&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;-c&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - |&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> CHECK_INFO=$(curl -s -w &amp;#39;http code:\t%{http_code}\n&amp;#39; 127.0.0.1/status)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> HTTP_CODE=$(echo -e &amp;#34;${CHECK_INFO}&amp;#34; | awk &amp;#39;/http code:/ {print $3}&amp;#39;)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> IDLE_PROCESSES=$(echo -e &amp;#34;${CHECK_INFO}&amp;#34; | awk &amp;#39;/idle processes:/ {print $3}&amp;#39;)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> [[ $HTTP_CODE -eq 200 &amp;amp;&amp;amp; $IDLE_PROCESSES -ge 10 ]] || exit 1&lt;/span> &lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0">
&lt;button
class="code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50"
title="Copy code"
>
&lt;div class="group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4">&lt;/div>
&lt;div class="hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;!-- raw HTML omitted -->
&lt;p>我們會用 curl 來打 &lt;code>/status&lt;/code>，檢查回傳的 http code 是否為 200，以及 idle processes 是否大於等於 10，如果不符合，就會回傳 1，讓他被標記不健康，讓 Kubernetes 停止流量到不健康的容器，以確保流量被路由到其他健康的副本。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2>問題&lt;span class="absolute -mt-20" id="問題">&lt;/span>
&lt;a href="#%e5%95%8f%e9%a1%8c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>當天遇到的情況是，我們上程式後，Pod 都一切正常，當流量開始進來後，發現 10 個 Pod 會開始偶發的噴 &lt;code>Readiness probe failed&lt;/code>，查看監控發現 processes 越來越低，最後被反應服務有問題，我們查看 Hpa 的紀錄的確有觸發到 40 個 Pod，只是查看 Pod 數還是依樣卡在 10 個，當下我們有嘗試使用調整 yaml 在 apply，發現 StatefulSet 的 yaml 也已經更新了，但 Pod 還是一樣卡在 10 個，也有使用 kubectl 下 &lt;code>kubectl scale sts [服務名稱] --replicas=0&lt;/code>，想要切換 Pod 數也沒有辦法。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>當下我們有先 Call Google 的 Support 一起找原因，Google 是建議我們 readiness 的條件不要設的太嚴格，可以加上 &lt;code>timeoutSeconds: 秒數&lt;/code>，但對於 Pod 卡住，還是沒有找到原因，後來我們查了一下 StatefulSet 的文件發現，StatefulSet 有一個設定 &lt;code>podManagementPolicy&lt;/code>，預設是 &lt;code>OrderedReady&lt;/code>，他必須等待前面的 Pod 是 Ready 狀態，才會再繼續建立新的，也就是說我們的 StatefulSet 已經卡住，導致就算 Hpa 觸發要長到 40 個 Pod 也沒有用。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2>解決辦法&lt;span class="absolute -mt-20" id="解決辦法">&lt;/span>
&lt;a href="#%e8%a7%a3%e6%b1%ba%e8%be%a6%e6%b3%95" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>當下想趕快解決 readiness 這個問題，調整 &lt;code>timeoutSeconds&lt;/code> 後，單純 apply 是沒有用的，要記得刪掉卡住的 Pod，讓他重新建立，才會套用新的設定 (但我們當下太在意為甚麼 Pod 會卡住，沒有想到要先把 readiness 問題修掉 xD，我們當下的解法是先將流量導到地端正常的服務上)。&lt;/p>
&lt;p>另外 Google 也說，假如我們還是必須使用 StatefulSet 來建立服務，建議我們把 podManagementPolicy 改成 &lt;code>Parallel&lt;/code>，它會有點像是 Deployment 的感覺，不會等待其他 Pod 變成 Ready 狀態，所以可以讓我們就算在 readiness 卡住的情況下，也可以自動擴縮服務。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;div class="overflow-x-auto mt-6 flex rounded-lg border py-2 ltr:pr-4 rtl:pl-4 contrast-more:border-current contrast-more:dark:border-current border-orange-100 bg-orange-50 text-orange-800 dark:border-orange-400/30 dark:bg-orange-400/20 dark:text-orange-300">
&lt;div class="ltr:pl-3 ltr:pr-2 rtl:pr-3 rtl:pl-2">&lt;/div>
&lt;div class="w-full min-w-0 leading-7">
&lt;div class="mt-6 leading-7 first:mt-0">
&lt;p>StatefulSet podManagementPolicy 參數說明&lt;/p>
&lt;ul>
&lt;li>OrderedReady (預設)&lt;/li>
&lt;/ul>
&lt;p>Pods 會按照順序一個接一個地被創建。即，n+1 號 Pod 不會在 n 號 Pod 成功創建且 Ready 之前開始創建。
在縮小 StatefulSet 的大小時，Pods 會按照反向順序一個接一個地被終止。即，n 號 Pod 不會在 n+1 號 Pod 完全終止之前開始終止。
這確保了 Pods 的啟動和終止的順序性。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;ul>
&lt;li>Parallel&lt;/li>
&lt;/ul>
&lt;p>所有 Pods 會同時地被創建或終止。
當 StatefulSet 擴展時，新的 Pods 會立即開始創建，不用等待其他 Pods 成為 Ready 狀態。
當縮小 StatefulSet 的大小時，要終止的 Pods 會立即開始終止，不用等待其他 Pods 先終止。
這種策略提供了快速的擴展和縮小操作，但缺乏順序性保證。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;!-- raw HTML omitted -->
&lt;h2>測試結果&lt;span class="absolute -mt-20" id="測試結果">&lt;/span>
&lt;a href="#%e6%b8%ac%e8%a9%a6%e7%b5%90%e6%9e%9c" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>最後我們就使用兩種模式來測試看看，已下是測試結果(透過 P1 才知道的設定ＱＱ)：&lt;/p>
&lt;p>有將測試的 StatefulSet 放在 Github，&lt;a href="https://github.com/880831ian/k8s-statefulset-podmanagementpolicy" target="_blank" rel="noopener">可以點我查看&lt;/a> (可以調整 readinessProbe 的 httpGet.Path 故意把他用壞)&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h3>使用 OrderedReady 模式&lt;span class="absolute -mt-20" id="使用-orderedready-模式">&lt;/span>
&lt;a href="#%e4%bd%bf%e7%94%a8-orderedready-%e6%a8%a1%e5%bc%8f" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>StatefulSet 在 podManagementPolicy 預設 OrderedReady 的模式，故意讓 readiness 卡住時 (Pod 卡住時)：&lt;/p>
&lt;ul>
&lt;li>當下的 StatefulSet 設定：&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;figure>
&lt;img src="https://pin-yi.me/k8s-statefulset-podmanagementpolicy/1.png" title="StatefulSet 設定" alt="" loading="lazy" />
&lt;figcaption>StatefulSet 設定&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>Pod 狀態：&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;figure>
&lt;img src="https://pin-yi.me/k8s-statefulset-podmanagementpolicy/2.png" title="Pod 狀態" alt="" loading="lazy" />
&lt;figcaption>Pod 狀態&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h4>使用指令調整 Pod 數量&lt;span class="absolute -mt-20" id="使用指令調整-pod-數量">&lt;/span>
&lt;a href="#%e4%bd%bf%e7%94%a8%e6%8c%87%e4%bb%a4%e8%aa%bf%e6%95%b4-pod-%e6%95%b8%e9%87%8f" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>我們這時候下指令調整 Pod 數量，看看會發生什麼事：&lt;/p>
&lt;div class="code-block relative mt-6 first:mt-0 group/code">&lt;pre>&lt;code>kubectl scale sts my-statefulset --replicas=5&lt;/code>&lt;/pre>&lt;div class="opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0">
&lt;button
class="code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50"
title="Copy code"
>
&lt;div class="group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4">&lt;/div>
&lt;div class="hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;!-- raw HTML omitted -->
&lt;p>我們先看 StatefulSet 的 yaml 可以看到 Pod replicas 已經改變，也可以看 generation 有更新，代表 StatefulSet 本身有接收到調整設定的請求。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;figure>
&lt;img src="https://pin-yi.me/k8s-statefulset-podmanagementpolicy/3.png" title="下指令調整後的 StatefulSet 設定" alt="" loading="lazy" />
&lt;figcaption>下指令調整後的 StatefulSet 設定&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>看了一下 Pod 數量，也是一樣卡住，且 Pod 數量也沒有變化。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;figure>
&lt;img src="https://pin-yi.me/k8s-statefulset-podmanagementpolicy/4.png" title="下指令調整後的 Pod 狀態" alt="" loading="lazy" />
&lt;figcaption>下指令調整後的 Pod 狀態&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h4>使用 yaml 調整 Pod 數量&lt;span class="absolute -mt-20" id="使用-yaml-調整-pod-數量">&lt;/span>
&lt;a href="#%e4%bd%bf%e7%94%a8-yaml-%e8%aa%bf%e6%95%b4-pod-%e6%95%b8%e9%87%8f" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>我們直接調整 StatefulSet yaml 的 Pod 數量，看看會發生什麼事：&lt;/p>
&lt;p>一樣我們先看 StatefulSet 的 yaml 可以看到 Pod replicas 已經改變(這裡應該切別的 Pod 數量，切回 3 個好像沒有意義 xD)，也可以看 generation 有更新。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;figure>
&lt;img src="https://pin-yi.me/k8s-statefulset-podmanagementpolicy/5.png" title="使用 yaml 調整後的 StatefulSet 設定" alt="" loading="lazy" />
&lt;figcaption>使用 yaml 調整後的 StatefulSet 設定&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>看了一下 Pod 數量，也是一樣卡住，且 Pod 數量也沒有變化。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;figure>
&lt;img src="https://pin-yi.me/k8s-statefulset-podmanagementpolicy/6.png" title="使用 yaml 調整後的 Pod 狀態" alt="" loading="lazy" />
&lt;figcaption>使用 yaml 調整後的 Pod 狀態&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>所以代表在 OrderedReady 的模式下，Pod 卡住時，無法對 Pod 進行任何操作，必須要手動刪除卡住的 Pod 才吃得到最新的設定。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h3>使用 Parallel 模式&lt;span class="absolute -mt-20" id="使用-parallel-模式">&lt;/span>
&lt;a href="#%e4%bd%bf%e7%94%a8-parallel-%e6%a8%a1%e5%bc%8f" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>StatefulSet 在 podManagementPolicy Parallel 的模式，故意讓 readiness 卡住時 (Pod 卡住時)：&lt;/p>
&lt;ul>
&lt;li>當下的 StatefulSet 設定：&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;figure>
&lt;img src="https://pin-yi.me/k8s-statefulset-podmanagementpolicy/7.png" title="StatefulSet 設定" alt="" loading="lazy" />
&lt;figcaption>StatefulSet 設定&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>Pod 狀態：&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;figure>
&lt;img src="https://pin-yi.me/k8s-statefulset-podmanagementpolicy/8.png" title="Pod 狀態" alt="" loading="lazy" />
&lt;figcaption>Pod 狀態&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h4>使用指令調整 Pod 數量&lt;span class="absolute -mt-20" id="使用指令調整-pod-數量-1">&lt;/span>
&lt;a href="#%e4%bd%bf%e7%94%a8%e6%8c%87%e4%bb%a4%e8%aa%bf%e6%95%b4-pod-%e6%95%b8%e9%87%8f-1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>我們這時候下指令調整 Pod 數量，看看會發生什麼事：&lt;/p>
&lt;div class="code-block relative mt-6 first:mt-0 group/code">&lt;pre>&lt;code>kubectl scale sts my-statefulset --replicas=5&lt;/code>&lt;/pre>&lt;div class="opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0">
&lt;button
class="code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50"
title="Copy code"
>
&lt;div class="group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4">&lt;/div>
&lt;div class="hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;!-- raw HTML omitted -->
&lt;p>我們先看 StatefulSet 的 yaml 可以看到 Pod replicas 已經改變，也可以看 generation 有更新，代表 StatefulSet 本身有接收到調整設定的請求。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;figure>
&lt;img src="https://pin-yi.me/k8s-statefulset-podmanagementpolicy/9.png" title="下指令調整後的 StatefulSet 設定" alt="" loading="lazy" />
&lt;figcaption>下指令調整後的 StatefulSet 設定&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>看了一下 Pod 數量，就算 my-statefulset-2 卡住，還是可以擴到 5 個 Pod。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;figure>
&lt;img src="https://pin-yi.me/k8s-statefulset-podmanagementpolicy/10.png" title="下指令調整後的 Pod 狀態" alt="" loading="lazy" />
&lt;figcaption>下指令調整後的 Pod 狀態&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h4>使用 yaml 調整 Pod 數量&lt;span class="absolute -mt-20" id="使用-yaml-調整-pod-數量-1">&lt;/span>
&lt;a href="#%e4%bd%bf%e7%94%a8-yaml-%e8%aa%bf%e6%95%b4-pod-%e6%95%b8%e9%87%8f-1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>我們直接調整 StatefulSet yaml 的 Pod 數量，看看會發生什麼事：&lt;/p>
&lt;p>一樣我們先看 StatefulSet 的 yaml 可以看到 Pod replicas 已經改變，也可以看 generation 有更新。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;figure>
&lt;img src="https://pin-yi.me/k8s-statefulset-podmanagementpolicy/11.png" title="使用 yaml 調整後的 StatefulSet 設定" alt="" loading="lazy" />
&lt;figcaption>使用 yaml 調整後的 StatefulSet 設定&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>看了一下 Pod 數量，也不會管其他 Pod 是否 Ready，一樣可以縮小成 2 個 Pod。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;figure>
&lt;img src="https://pin-yi.me/k8s-statefulset-podmanagementpolicy/12.png" title="使用 yaml 調整後的 Pod 狀態" alt="" loading="lazy" />
&lt;figcaption>使用 yaml 調整後的 Pod 狀態&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2>結論&lt;span class="absolute -mt-20" id="結論">&lt;/span>
&lt;a href="#%e7%b5%90%e8%ab%96" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>後來我們重新檢查了一下為什麼 processes 會用完，結果發現是 RD 的程式邏輯，導致每筆 Request 必須等待前一筆 Request 做完，才會開始動作，讓 processes 一直被占用，沒辦法即時消化，導致 processes 用完，又加上服務是使用 StatefulSet，預設模式的 OrderedReady，必須等待前一個 Pod 是 Ready 才可以自動擴縮，所以當我們 Hpa 想要擴縮，來增加可用的 processes 數量，也因為沒辦法擴縮，最後導致這一連串的問題 😕。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>另外，如果想要從 OrderedReady 模式切成 Parallel 模式 (反正過來也是)，必須先將原本的 StatefulSet 給刪除，才可以調整：&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;figure>
&lt;img src="https://pin-yi.me/k8s-statefulset-podmanagementpolicy/13.png" title="OrderedReady 模式切成 Parallel 模式" alt="" loading="lazy" />
&lt;figcaption>OrderedReady 模式切成 Parallel 模式&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2>參考資料&lt;span class="absolute -mt-20" id="參考資料">&lt;/span>
&lt;a href="#%e5%8f%83%e8%80%83%e8%b3%87%e6%96%99" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Kubernetes — 健康檢查：&lt;a href="https://medium.com/learn-or-die/kubernetes-%E5%81%A5%E5%BA%B7%E6%AA%A2%E6%9F%A5-59ee2a798115" target="_blank" rel="noopener">https://medium.com/learn-or-die/kubernetes-%E5%81%A5%E5%BA%B7%E6%AA%A2%E6%9F%A5-59ee2a798115&lt;/a>&lt;/p>
&lt;p>Pod Management Policies：&lt;a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#pod-management-policies" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#pod-management-policies&lt;/a>&lt;/p></description></item></channel></rss>